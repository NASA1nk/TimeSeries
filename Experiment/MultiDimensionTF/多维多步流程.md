# 数据

## 读取csv

读入多列的csv文件，选择时间和特定列数

- data：**(3936, 10)**

```bash
# data.head()
135	319.383260	151.610865	200.000000	261.290323	447.761194	336.864407	72.737686	327.891156	3252.100840	265.6250
136	362.334802	138.976627	170.140845	268.817204	389.552239	349.576271	81.328751	334.693878	3210.084034	250.0000
137	342.511013	145.293746	158.873239	249.462366	362.686567	302.966102	73.310424	337.414966	3411.764706	265.6250
138	343.612335	145.293746	145.352113	240.860215	392.537313	362.288136	72.737686	355.102041	3453.781513	273.4375
139	339.207048	151.610865	149.859155	219.354839	382.089552	298.728814	69.873998	344.217687	3336.134454	257.8125
```

`series = data.to_numpy()`：**(3936, 10)**

- 其中每个数据即一行的10列数据，一共3936行

```json
// series
array([[ 319.38325991,  151.61086545,  200.        , ...,  327.89115646,
        3252.10084034,  265.625     ],
       [ 362.33480176,  138.97662666,  170.14084507, ...,  334.69387755,
        3210.08403361,  250.        ],
       [ 342.51101322,  145.29374605,  158.87323944, ...,  337.41496599,
        3411.76470588,  265.625     ],
       ...,
       [ 748.89867841,  233.73341756,  187.04225352, ...,  771.42857143,
        5260.50420168,  570.3125    ],
       [ 686.12334802,  176.87934302,  181.97183099, ...,  663.94557823,
        4831.93277311,  585.9375    ],
       [ 525.33039648,  170.56222363,  185.91549296, ...,  606.80272109,
        4630.25210084,  570.3125    ]])
```

## 划分数据

选取2800长度的数据，即2800行

- data：**(2800,10)**

划分数据的目的是在这个2800*10的矩阵中对每10列同时维护一个input_window = 100的滑动窗口

- 所以一共有**len(data) - input_window = 2800 - 100 = 2700**个窗口
- 每个窗口data：**(100,10)**

> 行数（纵向长度）为100

### 输入

train_seq：**(100,10)**

> 多列是100*10，
>
> 单列的话，就1列数据，所以直接就是一个array是一个长度为100的数组，单列就是1*100

```json
// 由95个真实值和5个0拼接而成100
array([
   	   [-0.90168539, -0.54098361, -0.07988981, -0.51408451, -0.04545455,
        -0.25280899, -0.9       , -0.48230088, -0.83835182, -0.84210526],
      
     ...
       [-0.80898876, -0.54098361, -0.79614325, -0.59859155, -0.06168831,
        -0.13483146, -0.90555556, -0.42920354, -0.76228209, -0.73684211]
])

// output_window = 5
array([[0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]])


// 单列的数据
array([-0.40206378, -0.55946735, -0.60425452, -0.44742511, -0.58419515,
       -0.61932266, -0.69295419, -0.58351166, -0.54994044, -0.43662703,
       -0.61914435, -0.85068306, -0.48820822, -0.49690824, -0.60852687,
       -0.30539302, -0.67166959, -0.81256915, -0.72588739, -0.63647265,
       -0.35187454, -0.48203332, -0.46631505, -0.20902319, -0.55609022,
       -0.60737069, -0.63376441, -0.62251862, -0.83177698, -0.69605854,
       -0.59591266, -0.64712982, -0.72117908, -0.56725734, -0.49523732,
       -0.28346511, -0.40331179, -0.22654798, -0.49355597, -0.40401442,
       -0.55644669, -0.51327605, -0.54594082, -0.67255346, -0.5768457 ,
       -0.68445274, -0.68570625, -0.50959873, -0.53279995, -0.69369626,
       -0.77043888, -0.47404523, -0.53040862, -0.55402487, -0.52105681,
       -0.6572804 , -0.32012793, -0.45812272, -0.53512967, -0.44819954,
       -0.62960976, -0.5902882 , -0.54241652, -0.5205725 , -0.52635618,
       -0.70176632, -0.60213327, -0.61924325, -0.43668441, -0.45742335,
       -0.41136202, -0.39301151, -0.80772151, -0.6156968 , -0.53395663,
       -0.60273659, -0.36046779, -0.50490417, -0.44372466, -0.4931788 ,
       -0.4855132 , -0.41544793, -0.4899432 , -0.34648403, -0.58506004,
       -0.59291681, -0.53426938, -0.41909785, -0.4734859 , -0.49628204,
       -0.42389299, -0.5318    , -0.62608821, -0.4355949 , -0.44864787,
       -0.35575533, -0.52354333, -0.55667681, -0.6139897 , -0.50292192])
```

相当于在每一列后面补上了**output_window = 5**个0，即在整个数据加上了output_window = 5行的10个0

`np.append(arr, values, axis=None)`

- axis：可选参数，如果axis没有给出，那么arr，values都将先展平成一维数组
  - 如果axis被指定，那么arr和values需要同为一维数组或者**有相同的shape**
  - axis的最大值为数组**arr的维数-1**，当arr的维数为2，**axis=0表示沿着行增长方向添加values**，axis=1表示沿着列增长方向添加values

```python
train_seq = np.append(input_data[i:i+tw-output_window,:], np.zeros((output_window,10)),axis=0)
```

```json
array([
    	[-0.90168539, -0.54098361, -0.07988981, -0.51408451, -0.04545455,
        -0.25280899, -0.9       , -0.48230088, -0.83835182, -0.84210526],
		...
       [-0.80898876, -0.54098361, -0.79614325, -0.59859155, -0.06168831,
        -0.13483146, -0.90555556, -0.42920354, -0.76228209, -0.73684211],
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
         0.        ,  0.        ,  0.        ,  0.        ,  0.        ],
      ...
       [ 0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
         0.        ,  0.        ,  0.        ,  0.        ,  0.        ]
])
```

### inout

**一个train_seq和一个train_label组成一个输入输入(inout)**，即**(2,100,10)**

一共2700个数据，所以最后的train_data为**(2700,2,100,10)**

- **2700个窗口，每个数据由2个list组成，一个src，一个targets**，**每个list都是100*10，有100个数组组成，每个数组10个值**

train_data

> 单列数据是一列，所以series就是一行，横向滑动
>
> 多列数据是二维矩阵，每个series一行就对应一行多列数据，所以纵向滑动

```json
// 2700个窗口
tensor
([
    // [0]
    [
        // list[0] 输入
        [
            // 100*10
            [-0.9017, -0.5410, -0.0799,  ..., -0.4823, -0.8384, -0.8421],
            [-0.7921, -0.6066, -0.3719,  ..., -0.4712, -0.8542, -0.8947],
            [-0.8427, -0.5738, -0.4821,  ..., -0.4668, -0.7781, -0.8421],
                      ...,
            [ 0.0000,  0.0000,  0.0000,  ...,  0.0000,  0.0000,  0.0000],
            [ 0.0000,  0.0000,  0.0000,  ...,  0.0000,  0.0000,  0.0000],
            [ 0.0000,  0.0000,  0.0000,  ...,  0.0000,  0.0000,  0.0000]
        ],
        // list[1] 输出
        [
            // 100*10
            [-0.9017, -0.5410, -0.0799,  ..., -0.4823, -0.8384, -0.8421],
            [-0.7921, -0.6066, -0.3719,  ..., -0.4712, -0.8542, -0.8947],
            [-0.8427, -0.5738, -0.4821,  ..., -0.4668, -0.7781, -0.8421],
                      ...,
            [-0.7275, -0.6066, -0.8237,  ..., -0.2367, -0.6070, -0.7368],
            [-0.6517, -0.5410, -0.8733,  ..., -0.1748, -0.5658, -0.6842],
            [-0.6798, -0.5738, -0.8237,  ..., -0.3274, -0.6609, -0.6316]
        ]
    ],
		...
    // [2699]
    [
        // list[0]
        [
            [-0.6517, -0.5410, -0.7410,  ..., -0.3827, -0.9620, -0.7368],
            [-0.6601, -0.6393, -0.7631,  ..., -0.3872, -0.8637, -0.7895],
            [-0.7219, -0.6393, -0.7576,  ..., -0.4159, -0.9366, -0.7895],
            ...,
            [ 0.0000,  0.0000,  0.0000,  ...,  0.0000,  0.0000,  0.0000],
            [ 0.0000,  0.0000,  0.0000,  ...,  0.0000,  0.0000,  0.0000],
            [ 0.0000,  0.0000,  0.0000,  ...,  0.0000,  0.0000,  0.0000]
        ],
        // list[1]
        [
            [-0.6517, -0.5410, -0.7410,  ..., -0.3827, -0.9620, -0.7368],
            [-0.6601, -0.6393, -0.7631,  ..., -0.3872, -0.8637, -0.7895],
            [-0.7219, -0.6393, -0.7576,  ..., -0.4159, -0.9366, -0.7895],
            ...,
            [-0.6489, -0.5738, -0.7961,  ..., -0.3363, -0.9398, -0.8684],
            [-0.8399, -0.7049, -0.8017,  ..., -0.4049, -0.9271, -0.8684],
            [-0.8792, -0.6721, -0.7961,  ..., -0.3805, -0.9525, -0.8421]
        ]
    ]
])
```

# 训练

## batch

将train_data即**(2700,2,100,10)**根据**batch_size=32**划分为一个batch，得到**(32,2,100,10)**

进行如下处理

```python
input = torch.stack(torch.stack([item[0] for item in data]).chunk(input_window,1)).squeeze()
target = torch.stack(torch.stack([item[1] for item in data]).chunk(input_window,1)).squeeze()
```

`a = [item[0] for item in data]`

1. 拿到**(32,2,100,10)**的每个数据的第一个list，即输入**(100,10)**，得到**32个tensor，每个tensor都是(100,10)**


```json
// a
[
    tensor(
    // [0]
    [
            // 100*10
            [-0.9017, -0.5410, -0.0799, -0.5141, -0.0455, -0.2528, -0.9000, -0.4823,
             -0.8384, -0.8421],
            ...
            [ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,
              0.0000,  0.0000]
    ], device='cuda:0'), 

    // [1]
    tensor(
    [
            // 100*10
            [-0.7921, -0.6066, -0.3719, -0.4894, -0.1721, -0.2191, -0.8167, -0.4712,
             -0.8542, -0.8947],
            ...
            [ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,
              0.0000,  0.0000]
    ], device='cuda:0'), 
    ...
]
```

`b = torch.stack(a)`

2. 然后对这些数据进行stack拼接

   1. torch.stack(inputs, dim=?)，对inputs（多个tensor）沿指定维度dim拼接，返回一维的tensor
   2. **即这32个(100,10)的tensor拼在一起，返回一个(32,100,10)的一个大的tensor**

   > 相当于用一个大的tensor把这32个(100,10)的tensor包起来

```json
// b
tensor(
[
    // [0]
    [
        // 100 * 10
        // 100个数组，每个数组有10个值（100行，每行10个数）
        [-0.9017, -0.5410, -0.0799,  ..., -0.4823, -0.8384, -0.8421],
        [-0.7921, -0.6066, -0.3719,  ..., -0.4712, -0.8542, -0.8947],
        [-0.8427, -0.5738, -0.4821,  ..., -0.4668, -0.7781, -0.8421],
        ...,
        [ 0.0000,  0.0000,  0.0000,  ...,  0.0000,  0.0000,  0.0000],
        [ 0.0000,  0.0000,  0.0000,  ...,  0.0000,  0.0000,  0.0000],
        [ 0.0000,  0.0000,  0.0000,  ...,  0.0000,  0.0000,  0.0000]
    ],
        ...,
    // [31]
    [
        // 100 * 10
        [-0.7865, -0.4426, -0.6474,  ..., -0.4137, -0.8479, -0.8421],
        [-0.8399, -0.4426, -0.7355,  ..., -0.5000, -0.9144, -0.9211],
        [-0.7753, -0.5082, -0.7245,  ..., -0.4226, -0.9113, -0.8421],
        ...,
        [ 0.0000,  0.0000,  0.0000,  ...,  0.0000,  0.0000,  0.0000],
        [ 0.0000,  0.0000,  0.0000,  ...,  0.0000,  0.0000,  0.0000],
        [ 0.0000,  0.0000,  0.0000,  ...,  0.0000,  0.0000,  0.0000]
    ]
],
device='cuda:0')
```

**c = b.chunk(input_window,1)**

3. **然后对这些数据进行chunk切分**（关键）
   1. torch.chunk(tensor, chunk_num, dim)，将tensor**在指定维度上**分为chunk_num块，返回一个**tensor tuple**
   2. torch.chunk(x,input_window,1)：**这里就是(32,100,10)的第一维(100)上分成input_window = 100块，每一块是(32,1,10)**

> 这里就是把32个**(100,10)**的每一个(100,10)拿出来，**抽取每一个数据的相同行**
>
> - 即32个数据的第一行，组成一个**(32,1,10)**，32个数据的第二行，组成一个**(32,1,10)**
>
> - 一共100行，所以一共100个tensor

```json
// 长度为100的tensor tuple
(
// [0]
tensor(
    // (32,1,10)
    [   
        // 0
        [
            [-0.9017, -0.5410, -0.0799, -0.5141, -0.0455, -0.2528, -0.9000, -0.4823, -0.8384, -0.8421]
        ],
		// 1
        [
            [-0.7921, -0.6066, -0.3719, -0.4894, -0.1721, -0.2191, -0.8167, -0.4712, -0.8542, -0.8947]
        ],
      	...
		// 31
        [
            [-0.7865, -0.4426, -0.6474, -0.6761, -0.1981, -0.4382, -0.9222, -0.4137, -0.8479, -0.8421]
        ]
    ], device='cuda:0'
), 
// [1]    
tensor([[[-0.7921, -0.6066, -0.3719, -0.4894, -0.1721, -0.2191, -0.8167,
          -0.4712, -0.8542, -0.8947]],
		...
        [[-0.8399, -0.4426, -0.7355, -0.7113, -0.1623, -0.3427, -0.9389,
          -0.5000, -0.9144, -0.9211]]], device='cuda:0')
...
// [99]
tensor([[[0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]],
		...
        [[0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]]], device='cuda:0')
)
```

`d = torch.stack(c)`

3. 然后再把这个tensor tuple进行stack拼接， 返回一个大的tensor，即**(100,32,1,10)**

```json
tensor([
    	// 0
    	[
             // (32,1,10)
             // [0]
             [
                 // 1*10
                 [-0.9017, -0.5410, -0.0799,  ..., -0.4823, -0.8384, -0.8421]
             ],
             [[-0.7921, -0.6066, -0.3719,  ..., -0.4712, -0.8542, -0.8947]],
             ...,
             [[-0.8230, -0.5082, -0.6474,  ..., -0.4425, -0.7781, -0.8158]],
             [[-0.8455, -0.4754, -0.7135,  ..., -0.4027, -0.7433, -0.8421]],
			 // [31]
             [[-0.7865, -0.4426, -0.6474,  ..., -0.4137, -0.8479, -0.8421]]
       ],
		// 1
        [
       		 [[-0.7921, -0.6066, -0.3719,  ..., -0.4712, -0.8542, -0.8947]],
             [[-0.8427, -0.5738, -0.4821,  ..., -0.4668, -0.7781, -0.8421]],
             [[-0.8399, -0.5738, -0.6143,  ..., -0.4381, -0.7623, -0.8158]],
             ...,
             [[-0.8399, -0.4426, -0.7355,  ..., -0.5000, -0.9144, -0.9211]]
		],
		// 99
        [[[ 0.0000,  0.0000,  0.0000,  ...,  0.0000,  0.0000,  0.0000]],
         ...,
         [[ 0.0000,  0.0000,  0.0000,  ...,  0.0000,  0.0000,  0.0000]],
         [[ 0.0000,  0.0000,  0.0000,  ...,  0.0000,  0.0000,  0.0000]],
         [[ 0.0000,  0.0000,  0.0000,  ...,  0.0000,  0.0000,  0.0000]]]
],device='cuda:0')
```

`e = d.squeeze()`

- torch.squeeze(input, dim=None, out=None)：**去除size为1的维度，包括行和列，当维度大于等于2时，squeeze无作用**

所以**将(100,32,1,10)降维到(100,32,10)**

> 最终达到了把batch size换到中间的操作

```json
tensor([[[-0.9017, -0.5410, -0.0799,  ..., -0.4823, -0.8384, -0.8421],
         [-0.7921, -0.6066, -0.3719,  ..., -0.4712, -0.8542, -0.8947],
         [-0.8427, -0.5738, -0.4821,  ..., -0.4668, -0.7781, -0.8421],
         ...,
         [-0.8230, -0.5082, -0.6474,  ..., -0.4425, -0.7781, -0.8158],
         [-0.8455, -0.4754, -0.7135,  ..., -0.4027, -0.7433, -0.8421],
         [-0.7865, -0.4426, -0.6474,  ..., -0.4137, -0.8479, -0.8421]],

        [[-0.7921, -0.6066, -0.3719,  ..., -0.4712, -0.8542, -0.8947],
         [-0.8427, -0.5738, -0.4821,  ..., -0.4668, -0.7781, -0.8421],
         [-0.8399, -0.5738, -0.6143,  ..., -0.4381, -0.7623, -0.8158],
         ...,
         [-0.8455, -0.4754, -0.7135,  ..., -0.4027, -0.7433, -0.8421],
         [-0.7865, -0.4426, -0.6474,  ..., -0.4137, -0.8479, -0.8421],
         [-0.8399, -0.4426, -0.7355,  ..., -0.5000, -0.9144, -0.9211]],

        [[-0.8427, -0.5738, -0.4821,  ..., -0.4668, -0.7781, -0.8421],
         [-0.8399, -0.5738, -0.6143,  ..., -0.4381, -0.7623, -0.8158],
         [-0.8511, -0.5410, -0.5702,  ..., -0.4558, -0.8067, -0.8684],
         ...,
         [-0.7865, -0.4426, -0.6474,  ..., -0.4137, -0.8479, -0.8421],
         [-0.8399, -0.4426, -0.7355,  ..., -0.5000, -0.9144, -0.9211],
         [-0.7753, -0.5082, -0.7245,  ..., -0.4226, -0.9113, -0.8421]],
        ...,

        [[ 0.0000,  0.0000,  0.0000,  ...,  0.0000,  0.0000,  0.0000],
         [ 0.0000,  0.0000,  0.0000,  ...,  0.0000,  0.0000,  0.0000],
         [ 0.0000,  0.0000,  0.0000,  ...,  0.0000,  0.0000,  0.0000],
         ...,
         [ 0.0000,  0.0000,  0.0000,  ...,  0.0000,  0.0000,  0.0000],
         [ 0.0000,  0.0000,  0.0000,  ...,  0.0000,  0.0000,  0.0000],
         [ 0.0000,  0.0000,  0.0000,  ...,  0.0000,  0.0000,  0.0000]]],
       device='cuda:0')
```

